//
//  ForceTorchKit.swift
//  ForceTorch
//
//  Created by Denis Lavrov on 13/03/16.
//  Copyright (c) 2016 bahus. All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//



import UIKit

public class ForceTorchKit : NSObject {

    //// Drawing Methods

    public class func drawUIDesign() {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let gradientColor = UIColor(red: 0.183, green: 0.172, blue: 0.251, alpha: 1.000)
        var gradientColorRedComponent: CGFloat = 1,
            gradientColorGreenComponent: CGFloat = 1,
            gradientColorBlueComponent: CGFloat = 1
        gradientColor.getRed(&gradientColorRedComponent, green: &gradientColorGreenComponent, blue: &gradientColorBlueComponent, alpha: nil)

        let gradientColor2 = UIColor(red: (gradientColorRedComponent * 0.5), green: (gradientColorGreenComponent * 0.5), blue: (gradientColorBlueComponent * 0.5), alpha: (CGColorGetAlpha(gradientColor.CGColor) * 0.5 + 0.5))

        //// Gradient Declarations
        let background = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [gradientColor.CGColor, gradientColor2.CGColor], [0, 1])!

        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(rect: CGRectMake(0, 0, 414, 736))
        CGContextSaveGState(context)
        rectanglePath.addClip()
        CGContextDrawLinearGradient(context, background, CGPointMake(207, -0), CGPointMake(207, 736), CGGradientDrawingOptions())
        CGContextRestoreGState(context)


        //// Symbol Drawing
        let symbolRect = CGRectMake(138, 85, 138, 284)
        CGContextSaveGState(context)
        UIRectClip(symbolRect)
        CGContextTranslateCTM(context, symbolRect.origin.x, symbolRect.origin.y)

        ForceTorchKit.drawSlider()
        CGContextRestoreGState(context)


        //// Symbol 2 Drawing
        let symbol2Rect = CGRectMake(138, 246, 138, 138)
        CGContextSaveGState(context)
        UIRectClip(symbol2Rect)
        CGContextTranslateCTM(context, symbol2Rect.origin.x, symbol2Rect.origin.y)

        ForceTorchKit.drawButton()
        CGContextRestoreGState(context)


        //// Symbol 3 Drawing
        let symbol3Rect = CGRectMake(69, 479, 276, 183)
        CGContextSaveGState(context)
        UIRectClip(symbol3Rect)
        CGContextTranslateCTM(context, symbol3Rect.origin.x, symbol3Rect.origin.y)
        CGContextScaleCTM(context, symbol3Rect.size.width / 276, symbol3Rect.size.height / 184)

        ForceTorchKit.drawDisplay(power: "100")
        CGContextRestoreGState(context)
    }

    public class func drawSlider() {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let glowGreen = UIColor(red: 0.089, green: 0.900, blue: 0.589, alpha: 1.000)
        var glowGreenRedComponent: CGFloat = 1,
            glowGreenGreenComponent: CGFloat = 1,
            glowGreenBlueComponent: CGFloat = 1
        glowGreen.getRed(&glowGreenRedComponent, green: &glowGreenGreenComponent, blue: &glowGreenBlueComponent, alpha: nil)

        var glowGreenHueComponent: CGFloat = 1,
            glowGreenSaturationComponent: CGFloat = 1,
            glowGreenBrightnessComponent: CGFloat = 1
        glowGreen.getHue(&glowGreenHueComponent, saturation: &glowGreenSaturationComponent, brightness: &glowGreenBrightnessComponent, alpha: nil)

        let glowBlue = UIColor(hue: 0.5, saturation: glowGreenSaturationComponent, brightness: glowGreenBrightnessComponent, alpha: CGColorGetAlpha(glowGreen.CGColor))
        let color3 = UIColor(red: (glowGreenRedComponent * 0.7), green: (glowGreenGreenComponent * 0.7), blue: (glowGreenBlueComponent * 0.7), alpha: (CGColorGetAlpha(glowGreen.CGColor) * 0.7 + 0.3))

        //// Gradient Declarations
        let greenLight = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [glowGreen.CGColor, glowBlue.CGColor], [0, 1])!

        //// Shadow Declarations
        let bigShadow = NSShadow()
        bigShadow.shadowColor = UIColor.blackColor().colorWithAlphaComponent(0.75)
        bigShadow.shadowOffset = CGSizeMake(0.1, -0.1)
        bigShadow.shadowBlurRadius = 15
        let greenGlow = NSShadow()
        greenGlow.shadowColor = glowBlue
        greenGlow.shadowOffset = CGSizeMake(0.1, -0.1)
        greenGlow.shadowBlurRadius = 5

        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.moveToPoint(CGPointMake(129, 66))
        bezierPath.addLineToPoint(CGPointMake(129, 216))
        bezierPath.addCurveToPoint(CGPointMake(69, 276), controlPoint1: CGPointMake(129, 249.14), controlPoint2: CGPointMake(102.14, 276))
        bezierPath.addCurveToPoint(CGPointMake(9, 216), controlPoint1: CGPointMake(35.86, 276), controlPoint2: CGPointMake(9, 249.14))
        bezierPath.addLineToPoint(CGPointMake(9, 66))
        bezierPath.addCurveToPoint(CGPointMake(36.86, 15.32), controlPoint1: CGPointMake(9, 44.69), controlPoint2: CGPointMake(20.11, 25.97))
        bezierPath.addCurveToPoint(CGPointMake(69, 6), controlPoint1: CGPointMake(46.15, 9.42), controlPoint2: CGPointMake(57.18, 6))
        bezierPath.addCurveToPoint(CGPointMake(129, 66), controlPoint1: CGPointMake(102.14, 6), controlPoint2: CGPointMake(129, 32.86))
        bezierPath.closePath()
        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, greenGlow.shadowOffset, greenGlow.shadowBlurRadius, (greenGlow.shadowColor as! UIColor).CGColor)
        CGContextBeginTransparencyLayer(context, nil)
        bezierPath.addClip()
        CGContextDrawLinearGradient(context, greenLight, CGPointMake(69, 6), CGPointMake(69, 276), CGGradientDrawingOptions())
        CGContextEndTransparencyLayer(context)

        ////// Bezier Inner Shadow
        CGContextSaveGState(context)
        CGContextClipToRect(context, bezierPath.bounds)
        CGContextSetShadow(context, CGSizeMake(0, 0), 0)
        CGContextSetAlpha(context, CGColorGetAlpha((bigShadow.shadowColor as! UIColor).CGColor))
        CGContextBeginTransparencyLayer(context, nil)
        let bezierOpaqueShadow = (bigShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
        CGContextSetShadowWithColor(context, bigShadow.shadowOffset, bigShadow.shadowBlurRadius, bezierOpaqueShadow.CGColor)
        CGContextSetBlendMode(context, .SourceOut)
        CGContextBeginTransparencyLayer(context, nil)

        bezierOpaqueShadow.setFill()
        bezierPath.fill()

        CGContextEndTransparencyLayer(context)
        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)

        CGContextRestoreGState(context)



        //// Text Drawing
        let textRect = CGRectMake(15, 36, 108, 54)
        let textTextContent = NSString(string: "ON")
        let textStyle = NSParagraphStyle.defaultParagraphStyle().mutableCopy() as! NSMutableParagraphStyle
        textStyle.alignment = .Center

        let textFontAttributes = [NSFontAttributeName: UIFont(name: "DINAlternate-Bold", size: 40)!, NSForegroundColorAttributeName: color3, NSParagraphStyleAttributeName: textStyle]

        let textTextHeight: CGFloat = textTextContent.boundingRectWithSize(CGSizeMake(textRect.width, CGFloat.infinity), options: NSStringDrawingOptions.UsesLineFragmentOrigin, attributes: textFontAttributes, context: nil).size.height
        CGContextSaveGState(context)
        CGContextClipToRect(context, textRect);
        textTextContent.drawInRect(CGRectMake(textRect.minX, textRect.minY + (textRect.height - textTextHeight) / 2, textRect.width, textTextHeight), withAttributes: textFontAttributes)
        CGContextRestoreGState(context)


        //// Text 2 Drawing
        let text2Rect = CGRectMake(15, 194, 108, 54)
        let text2TextContent = NSString(string: "OFF")
        let text2Style = NSParagraphStyle.defaultParagraphStyle().mutableCopy() as! NSMutableParagraphStyle
        text2Style.alignment = .Center

        let text2FontAttributes = [NSFontAttributeName: UIFont(name: "DINAlternate-Bold", size: 40)!, NSForegroundColorAttributeName: color3, NSParagraphStyleAttributeName: text2Style]

        let text2TextHeight: CGFloat = text2TextContent.boundingRectWithSize(CGSizeMake(text2Rect.width, CGFloat.infinity), options: NSStringDrawingOptions.UsesLineFragmentOrigin, attributes: text2FontAttributes, context: nil).size.height
        CGContextSaveGState(context)
        CGContextClipToRect(context, text2Rect);
        text2TextContent.drawInRect(CGRectMake(text2Rect.minX, text2Rect.minY + (text2Rect.height - text2TextHeight) / 2, text2Rect.width, text2TextHeight), withAttributes: text2FontAttributes)
        CGContextRestoreGState(context)
    }

    public class func drawButtonLayer() {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let metalLight = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        var metalLightRedComponent: CGFloat = 1,
            metalLightGreenComponent: CGFloat = 1,
            metalLightBlueComponent: CGFloat = 1
        metalLight.getRed(&metalLightRedComponent, green: &metalLightGreenComponent, blue: &metalLightBlueComponent, alpha: nil)

        let metalDark = UIColor(red: (metalLightRedComponent * 0.7), green: (metalLightGreenComponent * 0.7), blue: (metalLightBlueComponent * 0.7), alpha: (CGColorGetAlpha(metalLight.CGColor) * 0.7 + 0.3))

        //// Gradient Declarations
        let metal = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [metalLight.CGColor, metalLight.blendedColorWithFraction(0.5, ofColor: metalDark).CGColor, metalDark.CGColor, metalDark.blendedColorWithFraction(0.5, ofColor: metalLight).CGColor, metalLight.CGColor], [0, 0.27, 0.51, 0.66, 1])!

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalInRect: CGRectMake(4, 4, 130, 130))
        CGContextSaveGState(context)
        ovalPath.addClip()
        CGContextDrawLinearGradient(context, metal,
            CGPointMake(134, 69),
            CGPointMake(4, 69),
            [CGGradientDrawingOptions.DrawsBeforeStartLocation, CGGradientDrawingOptions.DrawsAfterEndLocation])
        CGContextRestoreGState(context)
    }

    public class func drawButton() {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let metalLight = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        var metalLightRedComponent: CGFloat = 1,
            metalLightGreenComponent: CGFloat = 1,
            metalLightBlueComponent: CGFloat = 1
        metalLight.getRed(&metalLightRedComponent, green: &metalLightGreenComponent, blue: &metalLightBlueComponent, alpha: nil)

        let metalDark = UIColor(red: (metalLightRedComponent * 0.7), green: (metalLightGreenComponent * 0.7), blue: (metalLightBlueComponent * 0.7), alpha: (CGColorGetAlpha(metalLight.CGColor) * 0.7 + 0.3))

        //// Gradient Declarations
        let metal = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [metalLight.CGColor, metalLight.blendedColorWithFraction(0.5, ofColor: metalDark).CGColor, metalDark.CGColor, metalDark.blendedColorWithFraction(0.5, ofColor: metalLight).CGColor, metalLight.CGColor], [0, 0.27, 0.51, 0.66, 1])!

        //// Shadow Declarations
        let smallShadow = NSShadow()
        smallShadow.shadowColor = UIColor.blackColor()
        smallShadow.shadowOffset = CGSizeMake(0.1, -0.1)
        smallShadow.shadowBlurRadius = 5

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalInRect: CGRectMake(4, 4, 130, 130))
        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, smallShadow.shadowOffset, smallShadow.shadowBlurRadius, (smallShadow.shadowColor as! UIColor).CGColor)
        UIColor.grayColor().setFill()
        ovalPath.fill()
        CGContextRestoreGState(context)



        //// AngleBase Drawing
        let angleBaseRect = CGRectMake(0, 0, 138, 138)
        CGContextSaveGState(context)
        UIRectClip(angleBaseRect)
        CGContextTranslateCTM(context, angleBaseRect.origin.x, angleBaseRect.origin.y)

        ForceTorchKit.drawButtonLayer()
        CGContextRestoreGState(context)


        //// Angle45
        CGContextSaveGState(context)
        CGContextSetBlendMode(context, .Darken)
        CGContextBeginTransparencyLayer(context, nil)


        //// Symbol Drawing
        CGContextSaveGState(context)
        CGContextTranslateCTM(context, -29, 69.42)
        CGContextRotateCTM(context, -45 * CGFloat(M_PI) / 180)

        let symbolRect = CGRectMake(0, 0, 138, 138)
        CGContextSaveGState(context)
        UIRectClip(symbolRect)
        CGContextTranslateCTM(context, symbolRect.origin.x, symbolRect.origin.y)

        ForceTorchKit.drawButtonLayer()
        CGContextRestoreGState(context)

        CGContextRestoreGState(context)


        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)


        //// Angle90
        CGContextSaveGState(context)
        CGContextSetBlendMode(context, .Darken)
        CGContextBeginTransparencyLayer(context, nil)


        //// Symbol 3 Drawing
        CGContextSaveGState(context)
        CGContextTranslateCTM(context, 0, 138)
        CGContextRotateCTM(context, -90 * CGFloat(M_PI) / 180)

        let symbol3Rect = CGRectMake(0, 0, 138, 138)
        CGContextSaveGState(context)
        UIRectClip(symbol3Rect)
        CGContextTranslateCTM(context, symbol3Rect.origin.x, symbol3Rect.origin.y)

        ForceTorchKit.drawButtonLayer()
        CGContextRestoreGState(context)

        CGContextRestoreGState(context)


        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)


        //// Border Drawing
        let borderPath = UIBezierPath()
        borderPath.moveToPoint(CGPointMake(69, 8))
        borderPath.addCurveToPoint(CGPointMake(34.64, 18.59), controlPoint1: CGPointMake(56.25, 8), controlPoint2: CGPointMake(44.42, 11.91))
        borderPath.addCurveToPoint(CGPointMake(8, 69), controlPoint1: CGPointMake(18.55, 29.58), controlPoint2: CGPointMake(8, 48.06))
        borderPath.addCurveToPoint(CGPointMake(69, 130), controlPoint1: CGPointMake(8, 102.69), controlPoint2: CGPointMake(35.31, 130))
        borderPath.addCurveToPoint(CGPointMake(130, 69), controlPoint1: CGPointMake(102.69, 130), controlPoint2: CGPointMake(130, 102.69))
        borderPath.addCurveToPoint(CGPointMake(69, 8), controlPoint1: CGPointMake(130, 35.31), controlPoint2: CGPointMake(102.69, 8))
        borderPath.closePath()
        borderPath.moveToPoint(CGPointMake(134, 69))
        borderPath.addCurveToPoint(CGPointMake(69, 134), controlPoint1: CGPointMake(134, 104.9), controlPoint2: CGPointMake(104.9, 134))
        borderPath.addCurveToPoint(CGPointMake(4, 69), controlPoint1: CGPointMake(33.1, 134), controlPoint2: CGPointMake(4, 104.9))
        borderPath.addCurveToPoint(CGPointMake(31.08, 16.2), controlPoint1: CGPointMake(4, 47.25), controlPoint2: CGPointMake(14.68, 28))
        borderPath.addCurveToPoint(CGPointMake(69, 4), controlPoint1: CGPointMake(41.75, 8.52), controlPoint2: CGPointMake(54.85, 4))
        borderPath.addCurveToPoint(CGPointMake(134, 69), controlPoint1: CGPointMake(104.9, 4), controlPoint2: CGPointMake(134, 33.1))
        borderPath.closePath()
        CGContextSaveGState(context)
        borderPath.addClip()
        CGContextDrawLinearGradient(context, metal, CGPointMake(114.96, 23.04), CGPointMake(23.04, 114.96), CGGradientDrawingOptions())
        CGContextRestoreGState(context)
    }

    public class func drawDisplay(power power: String = "100") {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let glowGreen = UIColor(red: 0.089, green: 0.900, blue: 0.589, alpha: 1.000)
        var glowGreenRedComponent: CGFloat = 1,
            glowGreenGreenComponent: CGFloat = 1,
            glowGreenBlueComponent: CGFloat = 1
        glowGreen.getRed(&glowGreenRedComponent, green: &glowGreenGreenComponent, blue: &glowGreenBlueComponent, alpha: nil)

        var glowGreenHueComponent: CGFloat = 1,
            glowGreenSaturationComponent: CGFloat = 1,
            glowGreenBrightnessComponent: CGFloat = 1
        glowGreen.getHue(&glowGreenHueComponent, saturation: &glowGreenSaturationComponent, brightness: &glowGreenBrightnessComponent, alpha: nil)

        let glowBlue = UIColor(hue: 0.5, saturation: glowGreenSaturationComponent, brightness: glowGreenBrightnessComponent, alpha: CGColorGetAlpha(glowGreen.CGColor))
        let color3 = UIColor(red: (glowGreenRedComponent * 0.7), green: (glowGreenGreenComponent * 0.7), blue: (glowGreenBlueComponent * 0.7), alpha: (CGColorGetAlpha(glowGreen.CGColor) * 0.7 + 0.3))

        //// Gradient Declarations
        let greenLight = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [glowGreen.CGColor, glowBlue.CGColor], [0, 1])!

        //// Shadow Declarations
        let bigShadow = NSShadow()
        bigShadow.shadowColor = UIColor.blackColor().colorWithAlphaComponent(0.75)
        bigShadow.shadowOffset = CGSizeMake(0.1, -0.1)
        bigShadow.shadowBlurRadius = 15
        let greenGlow = NSShadow()
        greenGlow.shadowColor = glowBlue
        greenGlow.shadowOffset = CGSizeMake(0.1, -0.1)
        greenGlow.shadowBlurRadius = 5

        //// Variable Declarations
        let fullPower = power + " %"

        //// Rectangle Drawing
        let rectangleRect = CGRectMake(14, 12, 247, 156)
        let rectanglePath = UIBezierPath(roundedRect: rectangleRect, cornerRadius: 20)
        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, greenGlow.shadowOffset, greenGlow.shadowBlurRadius, (greenGlow.shadowColor as! UIColor).CGColor)
        CGContextBeginTransparencyLayer(context, nil)
        rectanglePath.addClip()
        CGContextDrawLinearGradient(context, greenLight, CGPointMake(137.5, 12), CGPointMake(137.5, 168), CGGradientDrawingOptions())
        CGContextEndTransparencyLayer(context)

        ////// Rectangle Inner Shadow
        CGContextSaveGState(context)
        CGContextClipToRect(context, rectanglePath.bounds)
        CGContextSetShadow(context, CGSizeMake(0, 0), 0)
        CGContextSetAlpha(context, CGColorGetAlpha((bigShadow.shadowColor as! UIColor).CGColor))
        CGContextBeginTransparencyLayer(context, nil)
        let rectangleOpaqueShadow = (bigShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
        CGContextSetShadowWithColor(context, bigShadow.shadowOffset, bigShadow.shadowBlurRadius, rectangleOpaqueShadow.CGColor)
        CGContextSetBlendMode(context, .SourceOut)
        CGContextBeginTransparencyLayer(context, nil)

        rectangleOpaqueShadow.setFill()
        rectanglePath.fill()

        CGContextEndTransparencyLayer(context)
        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)

        CGContextRestoreGState(context)

        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, greenGlow.shadowOffset, greenGlow.shadowBlurRadius, (greenGlow.shadowColor as! UIColor).CGColor)
        let rectangleStyle = NSParagraphStyle.defaultParagraphStyle().mutableCopy() as! NSMutableParagraphStyle
        rectangleStyle.alignment = .Center

        let rectangleFontAttributes = [NSFontAttributeName: UIFont(name: "DINAlternate-Bold", size: 80)!, NSForegroundColorAttributeName: color3, NSParagraphStyleAttributeName: rectangleStyle]

        let rectangleTextHeight: CGFloat = NSString(string: fullPower).boundingRectWithSize(CGSizeMake(rectangleRect.width, CGFloat.infinity), options: NSStringDrawingOptions.UsesLineFragmentOrigin, attributes: rectangleFontAttributes, context: nil).size.height
        CGContextSaveGState(context)
        CGContextClipToRect(context, rectangleRect);
        NSString(string: fullPower).drawInRect(CGRectMake(rectangleRect.minX, rectangleRect.minY + (rectangleRect.height - rectangleTextHeight) / 2, rectangleRect.width, rectangleTextHeight), withAttributes: rectangleFontAttributes)
        CGContextRestoreGState(context)
        CGContextRestoreGState(context)



        //// Text Drawing
        let textRect = CGRectMake(29, 22, 68, 21)
        let textTextContent = NSString(string: "Power:")
        let textStyle = NSParagraphStyle.defaultParagraphStyle().mutableCopy() as! NSMutableParagraphStyle
        textStyle.alignment = .Left

        let textFontAttributes = [NSFontAttributeName: UIFont(name: "DINAlternate-Bold", size: 22)!, NSForegroundColorAttributeName: color3, NSParagraphStyleAttributeName: textStyle]

        let textTextHeight: CGFloat = textTextContent.boundingRectWithSize(CGSizeMake(textRect.width, CGFloat.infinity), options: NSStringDrawingOptions.UsesLineFragmentOrigin, attributes: textFontAttributes, context: nil).size.height
        CGContextSaveGState(context)
        CGContextClipToRect(context, textRect);
        textTextContent.drawInRect(CGRectMake(textRect.minX, textRect.minY + (textRect.height - textTextHeight) / 2, textRect.width, textTextHeight), withAttributes: textFontAttributes)
        CGContextRestoreGState(context)
    }

    public class func drawBatteryIndicator() {
        //// Color Declarations
        let glowGreen = UIColor(red: 0.089, green: 0.900, blue: 0.589, alpha: 1.000)
        var glowGreenRedComponent: CGFloat = 1,
            glowGreenGreenComponent: CGFloat = 1,
            glowGreenBlueComponent: CGFloat = 1
        glowGreen.getRed(&glowGreenRedComponent, green: &glowGreenGreenComponent, blue: &glowGreenBlueComponent, alpha: nil)

        let color3 = UIColor(red: (glowGreenRedComponent * 0.7), green: (glowGreenGreenComponent * 0.7), blue: (glowGreenBlueComponent * 0.7), alpha: (CGColorGetAlpha(glowGreen.CGColor) * 0.7 + 0.3))

        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.moveToPoint(CGPointMake(173.36, 19))
        bezier2Path.addLineToPoint(CGPointMake(43.64, 19))
        bezier2Path.addCurveToPoint(CGPointMake(39.16, 19.37), controlPoint1: CGPointMake(41.44, 19), controlPoint2: CGPointMake(40.34, 19))
        bezier2Path.addCurveToPoint(CGPointMake(36.37, 22.16), controlPoint1: CGPointMake(37.86, 19.85), controlPoint2: CGPointMake(36.85, 20.86))
        bezier2Path.addLineToPoint(CGPointMake(36.33, 22.35))
        bezier2Path.addCurveToPoint(CGPointMake(36, 26.64), controlPoint1: CGPointMake(36, 23.34), controlPoint2: CGPointMake(36, 24.44))
        bezier2Path.addLineToPoint(CGPointMake(36, 83.36))
        bezier2Path.addCurveToPoint(CGPointMake(36.37, 87.84), controlPoint1: CGPointMake(36, 85.56), controlPoint2: CGPointMake(36, 86.66))
        bezier2Path.addCurveToPoint(CGPointMake(39.16, 90.63), controlPoint1: CGPointMake(36.85, 89.14), controlPoint2: CGPointMake(37.86, 90.15))
        bezier2Path.addLineToPoint(CGPointMake(39.35, 90.67))
        bezier2Path.addCurveToPoint(CGPointMake(43.64, 91), controlPoint1: CGPointMake(40.34, 91), controlPoint2: CGPointMake(41.44, 91))
        bezier2Path.addLineToPoint(CGPointMake(173.36, 91))
        bezier2Path.addCurveToPoint(CGPointMake(177.84, 90.63), controlPoint1: CGPointMake(175.56, 91), controlPoint2: CGPointMake(176.66, 91))
        bezier2Path.addCurveToPoint(CGPointMake(180.63, 87.84), controlPoint1: CGPointMake(179.14, 90.15), controlPoint2: CGPointMake(180.15, 89.14))
        bezier2Path.addLineToPoint(CGPointMake(180.67, 87.65))
        bezier2Path.addCurveToPoint(CGPointMake(181, 83.36), controlPoint1: CGPointMake(181, 86.66), controlPoint2: CGPointMake(181, 85.56))
        bezier2Path.addLineToPoint(CGPointMake(181, 26.64))
        bezier2Path.addCurveToPoint(CGPointMake(180.63, 22.16), controlPoint1: CGPointMake(181, 24.44), controlPoint2: CGPointMake(181, 23.34))
        bezier2Path.addCurveToPoint(CGPointMake(177.84, 19.37), controlPoint1: CGPointMake(180.15, 20.86), controlPoint2: CGPointMake(179.14, 19.85))
        bezier2Path.addLineToPoint(CGPointMake(177.65, 19.33))
        bezier2Path.addCurveToPoint(CGPointMake(173.36, 19), controlPoint1: CGPointMake(176.66, 19), controlPoint2: CGPointMake(175.56, 19))
        bezier2Path.closePath()
        bezier2Path.moveToPoint(CGPointMake(185.65, 11.33))
        bezier2Path.addLineToPoint(CGPointMake(185.84, 11.37))
        bezier2Path.addCurveToPoint(CGPointMake(188.63, 14.16), controlPoint1: CGPointMake(187.14, 11.85), controlPoint2: CGPointMake(188.15, 12.86))
        bezier2Path.addCurveToPoint(CGPointMake(189, 18.64), controlPoint1: CGPointMake(189, 15.34), controlPoint2: CGPointMake(189, 16.44))
        bezier2Path.addLineToPoint(CGPointMake(189, 92.36))
        bezier2Path.addCurveToPoint(CGPointMake(188.67, 96.65), controlPoint1: CGPointMake(189, 94.56), controlPoint2: CGPointMake(189, 95.66))
        bezier2Path.addLineToPoint(CGPointMake(188.63, 96.84))
        bezier2Path.addCurveToPoint(CGPointMake(185.84, 99.63), controlPoint1: CGPointMake(188.15, 98.14), controlPoint2: CGPointMake(187.14, 99.15))
        bezier2Path.addCurveToPoint(CGPointMake(181.36, 100), controlPoint1: CGPointMake(184.66, 100), controlPoint2: CGPointMake(183.56, 100))
        bezier2Path.addLineToPoint(CGPointMake(35.64, 100))
        bezier2Path.addCurveToPoint(CGPointMake(31.35, 99.67), controlPoint1: CGPointMake(33.44, 100), controlPoint2: CGPointMake(32.34, 100))
        bezier2Path.addLineToPoint(CGPointMake(31.16, 99.63))
        bezier2Path.addCurveToPoint(CGPointMake(28.37, 96.84), controlPoint1: CGPointMake(29.86, 99.15), controlPoint2: CGPointMake(28.85, 98.14))
        bezier2Path.addCurveToPoint(CGPointMake(28, 92.36), controlPoint1: CGPointMake(28, 95.66), controlPoint2: CGPointMake(28, 94.56))
        bezier2Path.addCurveToPoint(CGPointMake(28, 84), controlPoint1: CGPointMake(28, 92.36), controlPoint2: CGPointMake(28, 89.12))
        bezier2Path.addLineToPoint(CGPointMake(17.64, 84))
        bezier2Path.addCurveToPoint(CGPointMake(13.35, 83.67), controlPoint1: CGPointMake(15.44, 84), controlPoint2: CGPointMake(14.34, 84))
        bezier2Path.addLineToPoint(CGPointMake(13.16, 83.63))
        bezier2Path.addCurveToPoint(CGPointMake(10.37, 80.84), controlPoint1: CGPointMake(11.86, 83.15), controlPoint2: CGPointMake(10.85, 82.14))
        bezier2Path.addCurveToPoint(CGPointMake(10, 76.36), controlPoint1: CGPointMake(10, 79.66), controlPoint2: CGPointMake(10, 78.56))
        bezier2Path.addLineToPoint(CGPointMake(10, 34.64))
        bezier2Path.addCurveToPoint(CGPointMake(10.33, 30.35), controlPoint1: CGPointMake(10, 32.44), controlPoint2: CGPointMake(10, 31.34))
        bezier2Path.addLineToPoint(CGPointMake(10.37, 30.16))
        bezier2Path.addCurveToPoint(CGPointMake(13.16, 27.37), controlPoint1: CGPointMake(10.85, 28.86), controlPoint2: CGPointMake(11.86, 27.85))
        bezier2Path.addCurveToPoint(CGPointMake(17.64, 27), controlPoint1: CGPointMake(14.34, 27), controlPoint2: CGPointMake(15.44, 27))
        bezier2Path.addLineToPoint(CGPointMake(28, 27))
        bezier2Path.addCurveToPoint(CGPointMake(28, 18.64), controlPoint1: CGPointMake(28, 21.88), controlPoint2: CGPointMake(28, 18.64))
        bezier2Path.addCurveToPoint(CGPointMake(28.33, 14.35), controlPoint1: CGPointMake(28, 16.44), controlPoint2: CGPointMake(28, 15.34))
        bezier2Path.addLineToPoint(CGPointMake(28.37, 14.16))
        bezier2Path.addCurveToPoint(CGPointMake(31.16, 11.37), controlPoint1: CGPointMake(28.85, 12.86), controlPoint2: CGPointMake(29.86, 11.85))
        bezier2Path.addCurveToPoint(CGPointMake(35.64, 11), controlPoint1: CGPointMake(32.34, 11), controlPoint2: CGPointMake(33.44, 11))
        bezier2Path.addLineToPoint(CGPointMake(181.36, 11))
        bezier2Path.addCurveToPoint(CGPointMake(185.65, 11.33), controlPoint1: CGPointMake(183.56, 11), controlPoint2: CGPointMake(184.66, 11))
        bezier2Path.closePath()
        color3.setFill()
        bezier2Path.fill()


        //// Rectangle 4 Drawing
        let rectangle4Path = UIBezierPath(roundedRect: CGRectMake(42, 26, 29, 59), cornerRadius: 3)
        color3.setFill()
        rectangle4Path.fill()


        //// Rectangle 3 Drawing
        let rectangle3Path = UIBezierPath(roundedRect: CGRectMake(77, 26, 29, 59), cornerRadius: 3)
        color3.setFill()
        rectangle3Path.fill()


        //// Rectangle 2 Drawing
        let rectangle2Path = UIBezierPath(roundedRect: CGRectMake(112, 26, 29, 59), cornerRadius: 3)
        color3.setFill()
        rectangle2Path.fill()


        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(roundedRect: CGRectMake(147, 26, 29, 59), cornerRadius: 3)
        color3.setFill()
        rectanglePath.fill()
    }

    public class func drawUIBackground(frame frame: CGRect = CGRectMake(0, 0, 425, 748)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let gradientColor = UIColor(red: 0.183, green: 0.172, blue: 0.251, alpha: 1.000)
        var gradientColorRedComponent: CGFloat = 1,
            gradientColorGreenComponent: CGFloat = 1,
            gradientColorBlueComponent: CGFloat = 1
        gradientColor.getRed(&gradientColorRedComponent, green: &gradientColorGreenComponent, blue: &gradientColorBlueComponent, alpha: nil)

        let gradientColor2 = UIColor(red: (gradientColorRedComponent * 0.5), green: (gradientColorGreenComponent * 0.5), blue: (gradientColorBlueComponent * 0.5), alpha: (CGColorGetAlpha(gradientColor.CGColor) * 0.5 + 0.5))

        //// Gradient Declarations
        let background = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [gradientColor.CGColor, gradientColor2.CGColor], [0, 1])!

        //// Rectangle Drawing
        let rectangleRect = CGRectMake(frame.minX, frame.minY, floor((frame.width) * 1.00000 + 0.5), floor((frame.height) * 1.00000 + 0.5))
        let rectanglePath = UIBezierPath(rect: rectangleRect)
        CGContextSaveGState(context)
        rectanglePath.addClip()
        CGContextDrawLinearGradient(context, background,
            CGPointMake(rectangleRect.midX, rectangleRect.minY),
            CGPointMake(rectangleRect.midX, rectangleRect.maxY),
            CGGradientDrawingOptions())
        CGContextRestoreGState(context)
    }

    public class func drawIcon() {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let gradientColor = UIColor(red: 0.183, green: 0.172, blue: 0.251, alpha: 1.000)
        var gradientColorRedComponent: CGFloat = 1,
            gradientColorGreenComponent: CGFloat = 1,
            gradientColorBlueComponent: CGFloat = 1
        gradientColor.getRed(&gradientColorRedComponent, green: &gradientColorGreenComponent, blue: &gradientColorBlueComponent, alpha: nil)

        let gradientColor2 = UIColor(red: (gradientColorRedComponent * 0.5), green: (gradientColorGreenComponent * 0.5), blue: (gradientColorBlueComponent * 0.5), alpha: (CGColorGetAlpha(gradientColor.CGColor) * 0.5 + 0.5))
        let metalLight = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        var metalLightRedComponent: CGFloat = 1,
            metalLightGreenComponent: CGFloat = 1,
            metalLightBlueComponent: CGFloat = 1
        metalLight.getRed(&metalLightRedComponent, green: &metalLightGreenComponent, blue: &metalLightBlueComponent, alpha: nil)

        let metalDark = UIColor(red: (metalLightRedComponent * 0.7), green: (metalLightGreenComponent * 0.7), blue: (metalLightBlueComponent * 0.7), alpha: (CGColorGetAlpha(metalLight.CGColor) * 0.7 + 0.3))
        let glowRed = UIColor(red: 0.900, green: 0.089, blue: 0.089, alpha: 1.000)
        let golden = UIColor(red: 0.986, green: 1.000, blue: 0.000, alpha: 1.000)
        let golden2 = golden.colorWithAlphaComponent(0.2)

        //// Gradient Declarations
        let background = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [gradientColor.CGColor, gradientColor2.CGColor], [0, 1])!
        let metal = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [metalLight.CGColor, metalLight.blendedColorWithFraction(0.5, ofColor: metalDark).CGColor, metalDark.CGColor, metalDark.blendedColorWithFraction(0.5, ofColor: metalLight).CGColor, metalLight.CGColor], [0, 0.27, 0.51, 0.66, 1])!
        let inverseMetal = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [metalDark.CGColor, metalDark.blendedColorWithFraction(0.5, ofColor: metalLight).CGColor, metalLight.CGColor, metalLight.blendedColorWithFraction(0.5, ofColor: metalDark).CGColor, metalDark.CGColor], [0, 0.37, 0.5, 0.59, 1])!
        let goldenLight = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [golden.CGColor, golden.blendedColorWithFraction(0.5, ofColor: golden2).CGColor, golden2.CGColor], [0, 0.73, 1])!

        //// Shadow Declarations
        let redGlow = NSShadow()
        redGlow.shadowColor = glowRed
        redGlow.shadowOffset = CGSizeMake(0.1, -0.1)
        redGlow.shadowBlurRadius = 5

        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(roundedRect: CGRectMake(0, 0, 60, 60), cornerRadius: 10)
        CGContextSaveGState(context)
        rectanglePath.addClip()
        CGContextDrawLinearGradient(context, background, CGPointMake(30, -0), CGPointMake(30, 60), CGGradientDrawingOptions())
        CGContextRestoreGState(context)


        //// Oval 2 Drawing
        let oval2Path = UIBezierPath(ovalInRect: CGRectMake(26, -6, 9, 38))
        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, redGlow.shadowOffset, redGlow.shadowBlurRadius, (redGlow.shadowColor as! UIColor).CGColor)
        CGContextBeginTransparencyLayer(context, nil)
        oval2Path.addClip()
        CGContextDrawLinearGradient(context, goldenLight, CGPointMake(30.5, 32), CGPointMake(30.5, -6), CGGradientDrawingOptions())
        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)



        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalInRect: CGRectMake(22, 7, 17, 21))
        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, redGlow.shadowOffset, redGlow.shadowBlurRadius, (redGlow.shadowColor as! UIColor).CGColor)
        CGContextBeginTransparencyLayer(context, nil)
        ovalPath.addClip()
        CGContextDrawLinearGradient(context, goldenLight, CGPointMake(30.5, 28), CGPointMake(30.5, 7), CGGradientDrawingOptions())
        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)



        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.moveToPoint(CGPointMake(39, 21))
        bezier3Path.addLineToPoint(CGPointMake(35.36, 29.65))
        bezier3Path.addLineToPoint(CGPointMake(35.14, 29.65))
        bezier3Path.addCurveToPoint(CGPointMake(35.14, 50.86), controlPoint1: CGPointMake(35.14, 29.65), controlPoint2: CGPointMake(35.14, 45.09))
        bezier3Path.addCurveToPoint(CGPointMake(33.22, 52.77), controlPoint1: CGPointMake(34.72, 51.27), controlPoint2: CGPointMake(34.12, 51.88))
        bezier3Path.addCurveToPoint(CGPointMake(32.99, 53), controlPoint1: CGPointMake(33.14, 52.85), controlPoint2: CGPointMake(33.06, 52.93))
        bezier3Path.addCurveToPoint(CGPointMake(28.01, 53), controlPoint1: CGPointMake(32.99, 53), controlPoint2: CGPointMake(30.11, 53))
        bezier3Path.addCurveToPoint(CGPointMake(27.78, 52.77), controlPoint1: CGPointMake(27.94, 52.93), controlPoint2: CGPointMake(27.86, 52.85))
        bezier3Path.addCurveToPoint(CGPointMake(25.86, 50.86), controlPoint1: CGPointMake(26.88, 51.88), controlPoint2: CGPointMake(26.28, 51.27))
        bezier3Path.addCurveToPoint(CGPointMake(25.86, 29.65), controlPoint1: CGPointMake(25.86, 45.09), controlPoint2: CGPointMake(25.86, 29.65))
        bezier3Path.addLineToPoint(CGPointMake(25.64, 29.65))
        bezier3Path.addLineToPoint(CGPointMake(22, 21))
        bezier3Path.addLineToPoint(CGPointMake(39, 21))
        bezier3Path.closePath()
        CGContextSaveGState(context)
        bezier3Path.addClip()
        CGContextDrawLinearGradient(context, inverseMetal, CGPointMake(39, 37), CGPointMake(22, 37), CGGradientDrawingOptions())
        CGContextRestoreGState(context)


        //// Rectangle 2 Drawing
        let rectangle2Path = UIBezierPath(rect: CGRectMake(26, 30, 9, 1))
        metalDark.setFill()
        rectangle2Path.fill()


        //// Oval 3 Drawing
        let oval3Path = UIBezierPath(ovalInRect: CGRectMake(29, 35, 3, 3))
        metalDark.setFill()
        oval3Path.fill()


        //// Bezier 2 Drawing
        CGContextSaveGState(context)
        CGContextTranslateCTM(context, 45, 6.88)
        CGContextRotateCTM(context, -45 * CGFloat(M_PI) / 180)

        let bezier2Path = UIBezierPath()
        bezier2Path.moveToPoint(CGPointMake(2, 0))
        bezier2Path.addCurveToPoint(CGPointMake(2, 1), controlPoint1: CGPointMake(2, 0), controlPoint2: CGPointMake(2, 0.45))
        bezier2Path.addLineToPoint(CGPointMake(3, 1))
        bezier2Path.addLineToPoint(CGPointMake(3, 2))
        bezier2Path.addLineToPoint(CGPointMake(2, 2))
        bezier2Path.addCurveToPoint(CGPointMake(2, 3), controlPoint1: CGPointMake(2, 2.55), controlPoint2: CGPointMake(2, 3))
        bezier2Path.addLineToPoint(CGPointMake(1, 3))
        bezier2Path.addCurveToPoint(CGPointMake(1, 2), controlPoint1: CGPointMake(1, 3), controlPoint2: CGPointMake(1, 2.55))
        bezier2Path.addLineToPoint(CGPointMake(0, 2))
        bezier2Path.addLineToPoint(CGPointMake(0, 1))
        bezier2Path.addLineToPoint(CGPointMake(1, 1))
        bezier2Path.addCurveToPoint(CGPointMake(1, 0), controlPoint1: CGPointMake(1, 0.45), controlPoint2: CGPointMake(1, 0))
        bezier2Path.addLineToPoint(CGPointMake(2, 0))
        bezier2Path.addLineToPoint(CGPointMake(2, 0))
        bezier2Path.closePath()
        CGContextSaveGState(context)
        bezier2Path.addClip()
        CGContextDrawRadialGradient(context, metal,
            CGPointMake(1.5, 1.5), 2.37,
            CGPointMake(1.5, 1.5), 1.51,
            [CGGradientDrawingOptions.DrawsBeforeStartLocation, CGGradientDrawingOptions.DrawsAfterEndLocation])
        CGContextRestoreGState(context)

        CGContextRestoreGState(context)


        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.moveToPoint(CGPointMake(56, 13))
        bezier4Path.addCurveToPoint(CGPointMake(56, 14), controlPoint1: CGPointMake(56, 13), controlPoint2: CGPointMake(56, 13.45))
        bezier4Path.addLineToPoint(CGPointMake(57, 14))
        bezier4Path.addLineToPoint(CGPointMake(57, 15))
        bezier4Path.addLineToPoint(CGPointMake(56, 15))
        bezier4Path.addCurveToPoint(CGPointMake(56, 16), controlPoint1: CGPointMake(56, 15.55), controlPoint2: CGPointMake(56, 16))
        bezier4Path.addLineToPoint(CGPointMake(55, 16))
        bezier4Path.addCurveToPoint(CGPointMake(55, 15), controlPoint1: CGPointMake(55, 16), controlPoint2: CGPointMake(55, 15.55))
        bezier4Path.addLineToPoint(CGPointMake(54, 15))
        bezier4Path.addLineToPoint(CGPointMake(54, 14))
        bezier4Path.addLineToPoint(CGPointMake(55, 14))
        bezier4Path.addCurveToPoint(CGPointMake(55, 13), controlPoint1: CGPointMake(55, 13.45), controlPoint2: CGPointMake(55, 13))
        bezier4Path.addLineToPoint(CGPointMake(56, 13))
        bezier4Path.addLineToPoint(CGPointMake(56, 13))
        bezier4Path.closePath()
        CGContextSaveGState(context)
        bezier4Path.addClip()
        CGContextDrawRadialGradient(context, metal,
            CGPointMake(55.5, 14.5), 0.76,
            CGPointMake(55.5, 14.5), 1.51,
            [CGGradientDrawingOptions.DrawsBeforeStartLocation, CGGradientDrawingOptions.DrawsAfterEndLocation])
        CGContextRestoreGState(context)


        //// Bezier 5 Drawing
        CGContextSaveGState(context)
        CGContextTranslateCTM(context, 50, 24.88)
        CGContextRotateCTM(context, -45 * CGFloat(M_PI) / 180)

        let bezier5Path = UIBezierPath()
        bezier5Path.moveToPoint(CGPointMake(2, 0))
        bezier5Path.addCurveToPoint(CGPointMake(2, 1), controlPoint1: CGPointMake(2, 0), controlPoint2: CGPointMake(2, 0.45))
        bezier5Path.addLineToPoint(CGPointMake(3, 1))
        bezier5Path.addLineToPoint(CGPointMake(3, 2))
        bezier5Path.addLineToPoint(CGPointMake(2, 2))
        bezier5Path.addCurveToPoint(CGPointMake(2, 3), controlPoint1: CGPointMake(2, 2.55), controlPoint2: CGPointMake(2, 3))
        bezier5Path.addLineToPoint(CGPointMake(1, 3))
        bezier5Path.addCurveToPoint(CGPointMake(1, 2), controlPoint1: CGPointMake(1, 3), controlPoint2: CGPointMake(1, 2.55))
        bezier5Path.addLineToPoint(CGPointMake(0, 2))
        bezier5Path.addLineToPoint(CGPointMake(0, 1))
        bezier5Path.addLineToPoint(CGPointMake(1, 1))
        bezier5Path.addCurveToPoint(CGPointMake(1, 0), controlPoint1: CGPointMake(1, 0.45), controlPoint2: CGPointMake(1, 0))
        bezier5Path.addLineToPoint(CGPointMake(2, 0))
        bezier5Path.addLineToPoint(CGPointMake(2, 0))
        bezier5Path.closePath()
        CGContextSaveGState(context)
        bezier5Path.addClip()
        CGContextDrawRadialGradient(context, metal,
            CGPointMake(1.5, 1.5), 2.37,
            CGPointMake(1.5, 1.5), 1.51,
            [CGGradientDrawingOptions.DrawsBeforeStartLocation, CGGradientDrawingOptions.DrawsAfterEndLocation])
        CGContextRestoreGState(context)

        CGContextRestoreGState(context)


        //// Bezier 6 Drawing
        CGContextSaveGState(context)
        CGContextTranslateCTM(context, 2, 22.88)
        CGContextRotateCTM(context, -45 * CGFloat(M_PI) / 180)

        let bezier6Path = UIBezierPath()
        bezier6Path.moveToPoint(CGPointMake(2, 0))
        bezier6Path.addCurveToPoint(CGPointMake(2, 1), controlPoint1: CGPointMake(2, 0), controlPoint2: CGPointMake(2, 0.45))
        bezier6Path.addLineToPoint(CGPointMake(3, 1))
        bezier6Path.addLineToPoint(CGPointMake(3, 2))
        bezier6Path.addLineToPoint(CGPointMake(2, 2))
        bezier6Path.addCurveToPoint(CGPointMake(2, 3), controlPoint1: CGPointMake(2, 2.55), controlPoint2: CGPointMake(2, 3))
        bezier6Path.addLineToPoint(CGPointMake(1, 3))
        bezier6Path.addCurveToPoint(CGPointMake(1, 2), controlPoint1: CGPointMake(1, 3), controlPoint2: CGPointMake(1, 2.55))
        bezier6Path.addLineToPoint(CGPointMake(0, 2))
        bezier6Path.addLineToPoint(CGPointMake(0, 1))
        bezier6Path.addLineToPoint(CGPointMake(1, 1))
        bezier6Path.addCurveToPoint(CGPointMake(1, 0), controlPoint1: CGPointMake(1, 0.45), controlPoint2: CGPointMake(1, 0))
        bezier6Path.addLineToPoint(CGPointMake(2, 0))
        bezier6Path.addLineToPoint(CGPointMake(2, 0))
        bezier6Path.closePath()
        CGContextSaveGState(context)
        bezier6Path.addClip()
        CGContextDrawRadialGradient(context, metal,
            CGPointMake(1.5, 1.5), 2.37,
            CGPointMake(1.5, 1.5), 1.51,
            [CGGradientDrawingOptions.DrawsBeforeStartLocation, CGGradientDrawingOptions.DrawsAfterEndLocation])
        CGContextRestoreGState(context)

        CGContextRestoreGState(context)


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.moveToPoint(CGPointMake(16, 4))
        bezierPath.addCurveToPoint(CGPointMake(16, 5), controlPoint1: CGPointMake(16, 4), controlPoint2: CGPointMake(16, 4.45))
        bezierPath.addLineToPoint(CGPointMake(17, 5))
        bezierPath.addLineToPoint(CGPointMake(17, 6))
        bezierPath.addLineToPoint(CGPointMake(16, 6))
        bezierPath.addCurveToPoint(CGPointMake(16, 7), controlPoint1: CGPointMake(16, 6.55), controlPoint2: CGPointMake(16, 7))
        bezierPath.addLineToPoint(CGPointMake(15, 7))
        bezierPath.addCurveToPoint(CGPointMake(15, 6), controlPoint1: CGPointMake(15, 7), controlPoint2: CGPointMake(15, 6.55))
        bezierPath.addLineToPoint(CGPointMake(14, 6))
        bezierPath.addLineToPoint(CGPointMake(14, 5))
        bezierPath.addLineToPoint(CGPointMake(15, 5))
        bezierPath.addCurveToPoint(CGPointMake(15, 4), controlPoint1: CGPointMake(15, 4.45), controlPoint2: CGPointMake(15, 4))
        bezierPath.addLineToPoint(CGPointMake(16, 4))
        bezierPath.addLineToPoint(CGPointMake(16, 4))
        bezierPath.closePath()
        CGContextSaveGState(context)
        bezierPath.addClip()
        CGContextDrawRadialGradient(context, metal,
            CGPointMake(15.5, 5.5), 0.76,
            CGPointMake(15.5, 5.5), 1.51,
            [CGGradientDrawingOptions.DrawsBeforeStartLocation, CGGradientDrawingOptions.DrawsAfterEndLocation])
        CGContextRestoreGState(context)


        //// Bezier 7 Drawing
        let bezier7Path = UIBezierPath()
        bezier7Path.moveToPoint(CGPointMake(15, 17))
        bezier7Path.addCurveToPoint(CGPointMake(15, 18), controlPoint1: CGPointMake(15, 17), controlPoint2: CGPointMake(15, 17.45))
        bezier7Path.addLineToPoint(CGPointMake(16, 18))
        bezier7Path.addLineToPoint(CGPointMake(16, 19))
        bezier7Path.addLineToPoint(CGPointMake(15, 19))
        bezier7Path.addCurveToPoint(CGPointMake(15, 20), controlPoint1: CGPointMake(15, 19.55), controlPoint2: CGPointMake(15, 20))
        bezier7Path.addLineToPoint(CGPointMake(14, 20))
        bezier7Path.addCurveToPoint(CGPointMake(14, 19), controlPoint1: CGPointMake(14, 20), controlPoint2: CGPointMake(14, 19.55))
        bezier7Path.addLineToPoint(CGPointMake(13, 19))
        bezier7Path.addLineToPoint(CGPointMake(13, 18))
        bezier7Path.addLineToPoint(CGPointMake(14, 18))
        bezier7Path.addCurveToPoint(CGPointMake(14, 17), controlPoint1: CGPointMake(14, 17.45), controlPoint2: CGPointMake(14, 17))
        bezier7Path.addLineToPoint(CGPointMake(15, 17))
        bezier7Path.addLineToPoint(CGPointMake(15, 17))
        bezier7Path.closePath()
        CGContextSaveGState(context)
        bezier7Path.addClip()
        CGContextDrawRadialGradient(context, metal,
            CGPointMake(14.5, 18.5), 0.76,
            CGPointMake(14.5, 18.5), 1.51,
            [CGGradientDrawingOptions.DrawsBeforeStartLocation, CGGradientDrawingOptions.DrawsAfterEndLocation])
        CGContextRestoreGState(context)
    }

}



extension UIColor {
    func blendedColorWithFraction(fraction: CGFloat, ofColor color: UIColor) -> UIColor {
        var r1: CGFloat = 1.0, g1: CGFloat = 1.0, b1: CGFloat = 1.0, a1: CGFloat = 1.0
        var r2: CGFloat = 1.0, g2: CGFloat = 1.0, b2: CGFloat = 1.0, a2: CGFloat = 1.0

        self.getRed(&r1, green: &g1, blue: &b1, alpha: &a1)
        color.getRed(&r2, green: &g2, blue: &b2, alpha: &a2)

        return UIColor(red: r1 * (1 - fraction) + r2 * fraction,
            green: g1 * (1 - fraction) + g2 * fraction,
            blue: b1 * (1 - fraction) + b2 * fraction,
            alpha: a1 * (1 - fraction) + a2 * fraction);
    }
}
